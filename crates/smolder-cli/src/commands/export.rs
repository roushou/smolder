//! Export deployments to various formats

use std::collections::HashMap;

use clap::Args;
use color_eyre::eyre::{eyre, Result};
use console::style;
use serde::Serialize;

use smolder_db::{Database, DeploymentRepository};

/// Export deployments to various formats
#[derive(Args)]
pub struct ExportCommand {
    /// Output format: json, ts, env
    #[arg(long, default_value = "json")]
    pub format: String,

    /// Output file path
    #[arg(long, short)]
    pub output: Option<String>,
}

impl ExportCommand {
    pub async fn run(self) -> Result<()> {
        let db = Database::connect().await?;
        let deployments = DeploymentRepository::list_for_export(&db, None).await?;

        if deployments.is_empty() {
            println!("No deployments to export.");
            return Ok(());
        }

        let content = match self.format.as_str() {
            "json" => export_json(&deployments)?,
            "ts" => export_typescript(&deployments)?,
            "env" => export_env(&deployments)?,
            _ => {
                return Err(eyre!(
                    "Unknown format '{}'. Use: json, ts, env",
                    self.format
                ))
            }
        };

        match self.output {
            Some(path) => {
                std::fs::write(&path, &content)?;
                println!("{} Exported to {}", style("âœ“").green(), path);
            }
            None => {
                print!("{}", content);
            }
        }

        Ok(())
    }
}

#[derive(Serialize)]
struct ContractExport {
    address: String,
    abi: serde_json::Value,
    version: i64,
}

fn export_json(deployments: &[smolder_db::DeploymentView]) -> Result<String> {
    // Group by network -> contract
    let mut export: HashMap<String, HashMap<String, ContractExport>> = HashMap::new();

    for d in deployments {
        let network_map = export.entry(d.network_name.clone()).or_default();
        network_map.insert(
            d.contract_name.clone(),
            ContractExport {
                address: d.address.clone(),
                abi: serde_json::from_str(&d.abi)?,
                version: d.version,
            },
        );
    }

    Ok(serde_json::to_string_pretty(&export)?)
}

fn export_typescript(deployments: &[smolder_db::DeploymentView]) -> Result<String> {
    let mut output = String::new();
    output.push_str("// Auto-generated by smolder export\n\n");
    output.push_str("export const contracts = {\n");

    // Group by network
    let mut networks: HashMap<String, Vec<&smolder_db::DeploymentView>> = HashMap::new();
    for d in deployments {
        networks.entry(d.network_name.clone()).or_default().push(d);
    }

    for (network_name, contracts) in &networks {
        output.push_str(&format!("  {}: {{\n", network_name));

        for d in contracts {
            let abi: serde_json::Value = serde_json::from_str(&d.abi)?;
            output.push_str(&format!("    {}: {{\n", d.contract_name));
            output.push_str(&format!("      address: \"{}\" as const,\n", d.address));
            output.push_str(&format!(
                "      abi: {} as const,\n",
                serde_json::to_string(&abi)?
            ));
            output.push_str("    },\n");
        }

        output.push_str("  },\n");
    }

    output.push_str("} as const;\n");

    Ok(output)
}

fn export_env(deployments: &[smolder_db::DeploymentView]) -> Result<String> {
    let mut output = String::new();
    output.push_str("# Auto-generated by smolder export\n\n");

    for d in deployments {
        let var_name = format!(
            "{}_{}_ADDRESS",
            d.network_name.to_uppercase().replace('-', "_"),
            d.contract_name.to_uppercase()
        );
        output.push_str(&format!("{}={}\n", var_name, d.address));
    }

    Ok(output)
}
